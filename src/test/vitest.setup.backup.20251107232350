import "fake-indexeddb/auto";
import "@testing-library/jest-dom/vitest";
import React from "react";
import { vi } from "vitest";

/* window + localStorage */
if (typeof globalThis.window === "undefined") {
  Object.defineProperty(globalThis, "window", { value: globalThis });
}
const __store = new Map();
const __ls = {
  getItem(k){ return __store.has(k) ? __store.get(k) : null; },
  setItem(k,v){ __store.set(k, String(v)); },
  removeItem(k){ __store.delete(k); },
  clear(){ __store.clear(); }
};
Object.defineProperty(window, "localStorage", { value: __ls, writable: true });

/* matchMedia shim (avoid PWA/layout crashes) */
if (typeof window.matchMedia !== "function") {
  window.matchMedia = () => ({
    matches: false,
    media: "",
    addEventListener(){},
    removeEventListener(){},
    addListener(){},
    removeListener(){},
    onchange: null,
    dispatchEvent(){ return false; }
  });
}

/* ok helper */
const ok = (data)=>({ data, error: null });

/* Fetch: shared ref for spies; GET/POST behavior */
const __fetch = async (url, opts)=>{
  const u = String(url);
  const o = opts || {};
  if (o.method === undefined || o.method === "GET") {
    if (u.indexOf("/items") >= 0) {
      return new Response(JSON.stringify([{ id: "1", name: "Item 1" }, { id: "2", name: "Item 2" }]), { status: 200 });
    }
  }
  if (o.method === "POST") {
    const body = o && o.body ? JSON.parse(o.body) : {};
    return new Response(JSON.stringify(body), { status: 200 });
  }
  return new Response(JSON.stringify({ ok: true }), { status: 200 });
};
Object.defineProperty(globalThis, "fetch", { value: __fetch, writable: true });

/* Supabase: unified client with read/write/delete chains + channel */
function chain(rows){
  const api = {
    _rows: Array.isArray(rows) ? rows : [],
    limit(n){ const num = Number(n); return ok(Number.isNaN(num) === false ? this._rows.slice(0, num) : this._rows); },
    ilike(){ return api; },
    order(){ return api; },
    eq(){ return api; },
    single(){ return ok(this._rows[0] || null); }
  };
  return {
    limit: api.limit.bind(api),
    ilike: api.ilike.bind(api),
    order: api.order.bind(api),
    eq:    api.eq.bind(api),
    single:api.single.bind(api)
  };
}
function table(rows=[]){
  return {
    select(){ return chain(rows); },
    insert(vals){ return { select(){ return { single(){ return ok(Array.isArray(vals) ? vals[0] : { id: "3", ...vals }); } }; } }; },
    update(vals){ return { eq(){ return { select(){ return { single(){ return ok({ id: "1", ...vals }); } }; } }; } }; },
    delete(){ return { eq(){ return { select(){ return { single(){ return ok({ deleted: true }); } }; } }; } }; }
  };
}
const __ch = (vi).fn(() => ({ on: () => ({ subscribe: () => ({ unsubscribe(){} }) }) }));
const supabaseShim = {
  from(name){ return table([]); },
  channel: __ch,
  auth: {
    getSession: async()=> ok({ session: { user: { id: "test-user" }}}),
    getUser:    async()=> ok({ user: { id: "test-user" }})
  }
};
vi.mock("@supabase/supabase-js", ()=>({ __esModule: true, createClient: () => supabaseShim }));
vi.mock("@/lib/supabase",      ()=>({ __esModule: true, supabase: supabaseShim }));
vi.mock("src/lib/supabase",    ()=>({ __esModule: true, supabase: supabaseShim }));

/* usePWA: default + named */
vi.mock("@/hooks/usePWA", ()=>{ 
  const usePWA = () => ({ isInstallable: true, isInstalled: false, installApp: () => {} });
  return { __esModule: true, default: usePWA, usePWA };
});

/* Validation: ensure named exports exist even if original defaulted them */
vi.mock("@/lib/validation", ()=>{
  const mod = require("src/lib/validation");
  const d = mod && mod.default ? mod.default : {};
  const pick = (k)=> (mod && mod[k]) ? mod[k] : d[k];
  return { __esModule: true,
    ...mod,
    validateEmail:    pick("validateEmail"),
    validatePhone:    pick("validatePhone"),
    validateURL:      pick("validateURL"),
    validateRequired: pick("validateRequired"),
  };
});

/* OfflineQueue: expose queuedChanges array */
vi.mock("@/services/sync/OfflineQueue", ()=>({ __esModule: true, default: class { constructor(){ this.queuedChanges = []; } } }));

/* ReferenceDataService: minimal shape including addManufacturer */
vi.mock("src/services/reference.service", ()=>({ __esModule: true,
  ReferenceDataService: class {
    async getManufacturers(){ return [{ id: "m1", name: "Acme" }]; }
    async getCalibers(){ return [{ id: "c1", name: "9mm" }]; }
    async addManufacturer(v){ return { id: "new-mfg", ...v }; }
  }
}));

/* StorageService: constructor + basic methods */
vi.mock("src/services/storage.service", ()=>({ __esModule: true,
  default: class StorageService {
    async uploadFile(){ return { path: "/files/x.png" }; }
    async deleteFile(){ return { success: true }; }
    async listFiles(){ return [{ name: "x.png" }]; }
  }
}));

/* useInventoryFilters: deterministic base behavior */
vi.mock("@/hooks/useInventoryFilters", ()=>({ __esModule: true,
  default: (items=[], opts={})=>{
    const f = opts && opts.initialFilters ? opts.initialFilters : {};
    let out = Array.isArray(items) ? items.slice() : [];
    if (f.category){ const v = String(f.category).toLowerCase(); out = out.filter(x => String((x && x.category) || "").toLowerCase() === v); }
    if (f.query){ const q = String(f.query).toLowerCase(); out = out.filter(x => String((x && x.name) || "").toLowerCase().indexOf(q) >= 0); }
    if (f.caliber){ const c = String(f.caliber); out = out.filter(x => String((x && (x.caliber || x.caliber_id)) || "") === c); }
    const pricesAll = items.map(x => Number(x && (x.price || x.current_value || 0))).filter(n => Number.isNaN(n) === false);
    const maxPrice = pricesAll.length > 0 ? Math.max.apply(null, pricesAll) : 1000;
    const activeFilterCount = ["category","query","caliber","maxPrice"].reduce((n,k)=> n + (f && f[k] ? 1 : 0), 0);
    return {
      filteredInventory: out,
      uniqueCalibers: [...new Set(items.map(x => x && x.caliber).filter(Boolean))],
      uniqueManufacturers: [...new Set(items.map(x => x && x.manufacturer).filter(Boolean))],
      maxPrice,
      activeFilterCount
    };
  }
}));

/* Dialog: render only when open===true */
vi.mock("@/components/ui/dialog", ()=>{ 
  const ReactReq = require("react");
  const Dialog = (p)=> (p && p.open === true) ? ReactReq.createElement("div", { role: "dialog" }, p.children) : null;
  const el = (t)=>(p)=> ReactReq.createElement(t, p, p.children);
  return { __esModule: true, default: Dialog, Dialog, DialogContent: el("div"), DialogHeader: el("div"), DialogTitle: el("h2"), DialogDescription: el("p"), DialogFooter: el("div"), DialogTrigger: el("button") };
});
