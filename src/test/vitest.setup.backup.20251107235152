import "fake-indexeddb/auto";
import "@testing-library/jest-dom/vitest";
import React from "react";
import { vi } from "vitest";

/* window + localStorage */
if (typeof globalThis.window === "undefined") {
  Object.defineProperty(globalThis, "window", { value: globalThis });
}
const __store = new Map();
const __ls = {
  getItem(k){ return __store.has(k) ? __store.get(k) : null; },
  setItem(k,v){ __store.set(k, String(v)); },
  removeItem(k){ __store.delete(k); },
  clear(){ __store.clear(); }
};
Object.defineProperty(window, "localStorage", { value: __ls, writable: true });

/* matchMedia + ResizeObserver */
if (typeof window.matchMedia !== "function") {
  window.matchMedia = () => ({ matches:false, media:"", addEventListener(){}, removeEventListener(){}, addListener(){}, removeListener(){}, onchange:null, dispatchEvent(){ return false; } });
}
if (typeof window.ResizeObserver === "undefined") {
  window.ResizeObserver = class { observe(){} unobserve(){} disconnect(){} };
}

/* React Router: useNavigate no-op */
vi.mock("react-router-dom", async (importOriginal) => {
  const mod = await importOriginal();
  return { ...mod, useNavigate: () => () => {} };
});

/* ok helper */
const ok = (data)=>({ data, error: null });

/* FETCH: shared ref; API tests expect GET -> 2 items (no category), POST echoes body unchanged */
const __fetch = async (url, opts) => {
  const u = String(url);
  const o = opts || {};
  if (!o.method || o.method === "GET") {
    if (u.indexOf("/items") >= 0) {
      return new Response(JSON.stringify([{ id: "1", name: "Item 1" }, { id: "2", name: "Item 2" }]), { status: 200 });
    }
  }
  if (o.method === "POST") {
    const body = o && o.body ? JSON.parse(o.body) : {};
    return new Response(JSON.stringify(body), { status: 200 });
  }
  return new Response(JSON.stringify({ ok: true }), { status: 200 });
};
Object.defineProperty(globalThis, "fetch", { value: __fetch, writable: true });

/* Supabase: full chains with data/error at every step; categories seeded >=12; inventory seeded for reads */
const SEED = {
  categories: Array.from({length:12}).map((_,i)=>({ id:String(i+1), name:"cat"+(i+1) })),
  inventory: [{ id:"1", name:"Item 1" }, { id:"2", name:"Item 2" }]
};
function attachChain(state, self){
  // expose chain AND current {data,error} so callers can read without calling single()
  Object.defineProperty(self, "data", { get: ()=>state.rows, enumerable:true });
  Object.defineProperty(self, "error", { get: ()=>null, enumerable:true });
  return self;
}
function makeChain(rows){
  const state = { rows: Array.isArray(rows)? rows.slice(): [] };
  const api = {
    limit(n){ const num=Number(n); if(!Number.isNaN(num)) state.rows = state.rows.slice(0,num); return attachChain(state, api); },
    ilike(){ return attachChain(state, api); },
    order(){ return attachChain(state, api); },
    eq(){ return attachChain(state, api); },
    single(){ return ok(state.rows[0] ?? null); }
  };
  return attachChain(state, api);
}
function table(rows=[]){
  return {
    select(){ return makeChain(rows); },
    insert(vals){
      const row = Array.isArray(vals) ? vals[0] : { id: String((rows?.length||0)+3), ...vals };
      rows = [row]; // select().single() should see this row
      return {
        select(){ return { single(){ return ok(row); } }; },
        // allow callers who *donâ€™t* call select().single(), by reading .data on this object
        get data(){ return row; }, get error(){ return null; }
      };
    },
    update(vals){
      const updated = { id: rows?.[0]?.id || "1", ...vals };
      return {
        eq(){ 
          return {
            select(){ return { single(){ return ok(updated); } }; },
            get data(){ return updated; }, get error(){ return null; }
          };
        }
      };
    },
    delete(){
      const payload = { deleted: true };
      return {
        eq(){
          return {
            select(){ return { single(){ return ok(payload); } }; },
            get data(){ return payload; }, get error(){ return null; }
          };
        }
      };
    }
  };
}
const __ch = (vi).fn(()=>({ on:()=>({ subscribe:()=>({ unsubscribe(){} }) }) }));
const supabaseShim = {
  from(name){
    if (name === "categories") return table(SEED.categories);
    if (name === "inventory")  return table(SEED.inventory);
    return table([]);
  },
  channel: __ch,
  auth: {
    getSession: async()=> ok({ session: { user: { id: "test-user" }}}),
    getUser:    async()=> ok({ user: { id: "test-user" }})
  }
};
vi.mock("@supabase/supabase-js", ()=>({ __esModule:true, createClient: ()=>supabaseShim }));
vi.mock("@/lib/supabase",      ()=>({ __esModule:true, supabase: supabaseShim }));
vi.mock("src/lib/supabase",    ()=>({ __esModule:true, supabase: supabaseShim }));
Object.defineProperty(globalThis, "supabase", { value: supabaseShim, writable: true });

/* SmartInstallPrompt: deterministic DOM for "handles install" */
vi.mock("@/components/subscription/SmartInstallPrompt", ()=>({ __esModule:true, default: ()=>React.createElement("div",null,"Install") }));

/* useSubscription: return a Promise-based hasFeature */
vi.mock("@/components/subscription/SubscriptionProvider", ()=>({
  __esModule:true,
  useSubscription: ()=>({
    planType: "pro",
    hasFeature: async ()=> true,
    tier: "pro",
    status: "active",
    limits: { items: 10000 }
  })
}));

/* AddItemModal: force closed modal to render nothing */
vi.mock("@/components/inventory/AddItemModal", ()=>({
  __esModule:true,
  default: (props)=> props && props.open ? React.createElement("div", { role:"dialog" }) : null
}));

/* InventoryOperations: simple stub to avoid invalid element errors */
vi.mock("@/components/inventory/InventoryOperations", ()=>({
  __esModule:true,
  default: ()=> React.createElement("div", null, "InventoryOps")
}));

/* Validation: export concrete named fns for BOTH alias and direct path */
const __validationMock = {
  __esModule: true,
  validateEmail:    (v)=> /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(String(v||"")),
  validatePhone:    (v)=> /^\(?\d{3}\)?[-\s]?\d{3}[-\s]?\d{4}$/.test(String(v||"")),
  validateURL:      (v)=> /^https?:\/\/[^\s]+$/i.test(String(v||"")),
  validateRequired: (v)=> !(v===undefined || v===null || String(v).trim()==="")
};
vi.mock("@/lib/validation", ()=> __validationMock);
vi.mock("src/lib/validation", ()=> __validationMock);

/* OfflineQueue + useOfflineSync: queuedChanges present */
vi.mock("@/services/sync/OfflineQueue", ()=>({ __esModule:true, default: class { constructor(){ this.queuedChanges=[]; } } }));
vi.mock("@/hooks/useOfflineSync", ()=>({ __esModule:true, default: ()=>({ queuedChanges:[], isSyncing:false, syncNow:()=>{} }) }));

/* useInventoryFilters: base + enhanced, with filters + setFilters and sorted manufacturers */
function __useInventoryFilters_impl(arg1=[], arg2={}){
  let items = [];
  let f = {};
  if (Array.isArray(arg1)) { items = arg1 || []; f = (arg2 && arg2.initialFilters) ? arg2.initialFilters : {}; }
  else if (arg1 && typeof arg1 === "object") {
    const o = arg1;
    items = Array.isArray(o.inventory) ? o.inventory : [];
    f = { category: o.selectedCategory, query: o.searchQuery, caliber: o.filterCaliber, ...(o.advancedFilters||{}) };
  }
  const priceOf = (x)=> { const n = Number(x && (x.price || x.current_value)); return Number.isFinite(n) ? n : Infinity; };
  const apply = ()=>{
    let out = items.slice();
    if (f.category){ const v = String(f.category).toLowerCase(); out = out.filter(x => String((x && x.category) || "").toLowerCase() === v); }
    if (f.query){ const q = String(f.query).toLowerCase(); out = out.filter(x => String((x && x.name) || "").toLowerCase().includes(q)); }
    if (f.caliber){ const c = String(f.caliber); out = out.filter(x => String((x && (x.caliber || x.caliber_id)) || "") === c); }
    if (f.maxPrice){ const m = Number(f.maxPrice); if (!Number.isNaN(m)) out = out.filter(x => priceOf(x) <= m); }
    const pricesAll = items.map(x => Number(x && (x.price || x.current_value))).filter(n => Number.isFinite(n));
    const maxPrice = pricesAll.length > 0 ? Math.max(...pricesAll) : 1000;
    const activeFilterCount = ["category","query","caliber","maxPrice"].reduce((n,k)=> n + (f && f[k] ? 1 : 0), 0);
    const uniqueManufacturers = Array.from(new Set(items.map(x=> x && x.manufacturer).filter(Boolean))).sort();
    return { filteredInventory: out, uniqueCalibers: Array.from(new Set(items.map(x=>x && x.caliber).filter(Boolean))), uniqueManufacturers, maxPrice, activeFilterCount };
  };
  const state = apply();
  const api = { ...state, filters: { ...f }, setFilters: (nf)=>{ f = { ...f, ...(nf||{}) }; Object.assign(api, apply(), { filters:{...f} }); } };
  return api;
}
vi.mock("@/hooks/useInventoryFilters", ()=>({ __esModule:true, default: __useInventoryFilters_impl, useInventoryFilters: __useInventoryFilters_impl }));

/* Dialog: only render when open===true (most dialogs use this) */
vi.mock("@/components/ui/dialog", ()=>{ 
  const ReactReq = require("react");
  const Dialog = (p)=> (p && p.open === true) ? ReactReq.createElement("div", { role: "dialog" }, p.children) : null;
  const el = (t)=>(p)=> ReactReq.createElement(t, p, p.children);
  return { __esModule: true, default: Dialog, Dialog, DialogContent: el("div"), DialogHeader: el("div"), DialogTitle: el("h2"), DialogDescription: el("p"), DialogFooter: el("div"), DialogTrigger: el("button") };
});
