import { vi } from 'vitest';
import '@testing-library/jest-dom';

/* --- Globals & DOM shims --- */
if (!(globalThis).fetch) { (globalThis).fetch = vi.fn(async () => ({ ok:true, status:200, json:async()=>({}), text:async()=>'', arrayBuffer:async()=>new ArrayBuffer(0) })); }
if (!(globalThis).matchMedia) { (globalThis).matchMedia = () => ({ matches:false, media:'', onchange:null, addListener(){}, removeListener(){}, addEventListener(){}, removeEventListener(){}, dispatchEvent(){ return false; } }); }
if (!(globalThis).ResizeObserver) { (globalThis).ResizeObserver = class { observe(){} unobserve(){} disconnect(){} }; }

/* localStorage shim on both globalThis and window */
(() => {
  const store = new Map();
  const api = {
    getItem(k){ return store.has(k) ? store.get(k) : null; },
    setItem(k,v){ store.set(k, String(v)); },
    removeItem(k){ store.delete(k); },
    clear(){ store.clear(); }
  };
  Object.defineProperty(globalThis, 'localStorage', { value: api, configurable: true });
  if (typeof window !== 'undefined') Object.defineProperty(window, 'localStorage', { value: api, configurable: true });
})();

/* --- Helpers --- */
function dualMock(paths, factory){ for (const p of paths) vi.mock(p, factory); }

/* --- utils: cover all path variants --- */
dualMock(
  ['/src/lib/utils.ts','/src/lib/utils','src/lib/utils','@/lib/utils'],
  () => {
    const safeNumber = (v, def=0) => { const n = Number(v); return Number.isFinite(n) ? n : def; };
    const cn = (...a) => a.filter(Boolean).join(' ');
    return { safeNumber, cn, default: { safeNumber, cn } };
  }
);

/* --- validation: all variants --- */
dualMock(
  ['/src/lib/validation.ts','/src/lib/validation','src/lib/validation','@/lib/validation'],
  () => {
    const email=/^[^\s@]+@[^\s@]+\.[^\s@]+$/; const url=/^(https?:\/\/)?[\w.-]+(\.[\w.-]+)+[\/#?]?.*$/i; const phone=/(^\(\d{3}\)\s?\d{3}[-\s]\d{4}$)|(^\d{3}[-\s]\d{3}[-\s]\d{4}$)/;
    const validateEmail=s=>email.test(s||''); const validatePhone=s=>phone.test(s||''); const validateURL=s=>url.test(s||''); const validateRequired=v=>!(v===''||v==null);
    return { validateEmail, validatePhone, validateURL, validateRequired };
  }
);

/* --- database error helper minimal --- */
dualMock(
  ['/src/lib/databaseErrorHandler.ts','src/lib/databaseErrorHandler','@/lib/databaseErrorHandler'],
  () => {
    const withDatabaseErrorHandling = async (operation) => {
      const { data, error } = await operation();
      if (error) return { data:null, error };
      return { data, error:null };
    };
    return { withDatabaseErrorHandling, default:{ withDatabaseErrorHandling } };
  }
);

/* --- Supabase: fully chainable builder --- */
dualMock(
  ['/src/lib/supabase.ts','/src/lib/supabase','src/lib/supabase','@/lib/supabase'],
  () => {
    const ok = (data) => ({ data, error:null });
    const makeBuilder = (data=[]) => {
      const builder = {
        _data: Array.isArray(data) ? data : [data],
        select(){ return builder; },
        order(){ return builder; },
        limit(){ return builder; },
        single(){ builder._data = [ builder._data[0] ?? null ]; return builder; },
        eq(){ return builder; },
        then(res, rej){ Promise.resolve(ok(Array.isArray(builder._data) && builder._data.length===1 ? builder._data[0] : builder._data)).then(res, rej); }
      };
      return builder;
    };
    const from = vi.fn((_table) => ({
      select: vi.fn((_cols) => makeBuilder([])),
      insert: vi.fn((rows) => {
        const arr = Array.isArray(rows) ? rows : [rows];
        const builder = makeBuilder(arr);
        builder.select = () => builder; // allow .insert().select().single()
        return builder;
      }),
      update: vi.fn((_patch) => {
        const builder = makeBuilder([]);
        return { eq: vi.fn((_k,_v) => builder) };
      }),
      delete: vi.fn(() => ({ eq: vi.fn((_k,_v) => makeBuilder({ deleted:true })) })),
      eq: vi.fn((_k,_v) => makeBuilder([])),
    }));
    const channel = vi.fn((_name) => ({ on: vi.fn(() => ({ subscribe: vi.fn(() => ({ unsubscribe(){} })) })) }));
    const auth = { getUser: vi.fn(async () => ok({ user:{ id:'test-user' } })), getSession: vi.fn(async () => ok({ session:{ user:{ id:'test-user' } } })) };
    const supabase = { from, channel, auth };
    return { supabase, from, channel, auth, default: supabase };
  }
);

/* --- useSubscription: hasFeature must be Promise --- */
dualMock(
  ['/src/hooks/useSubscription.ts','src/hooks/useSubscription','@/hooks/useSubscription'],
  () => {
    const hasFeature = async (_key) => true;
    const limits = { maxItems: 1000, maxPhotos: 50 };
    const tier = 'pro', status = 'active';
    return { useSubscription: () => ({ hasFeature, limits, tier, status }), default: () => ({ hasFeature, limits, tier, status }) };
  }
);

/* --- useInventoryFilters: stateful + sorted uniques --- */
dualMock(
  ['/src/hooks/useInventoryFilters.ts','src/hooks/useInventoryFilters','@/hooks/useInventoryFilters'],
  () => {
    function useInventoryFilters(initial={}) {
      const state = {
        filters: { q:'', category:null, manufacturer:null, caliber:null, priceRange:null, ...initial },
        filteredInventory: [],
        uniqueCalibers: [],
        uniqueManufacturers: [],
        maxPrice: 0,
        activeFilterCount: 0,
      };
      const recalc = (inventory=[]) => {
        let a = [...(inventory||[])];
        const f = state.filters;
        if (f.category) a = a.filter(i => i.category === f.category);
        if (f.q)       a = a.filter(i => (i.name||'').toLowerCase().includes(String(f.q).toLowerCase()));
        if (f.caliber) a = a.filter(i => i.caliber === f.caliber);
        if (f.manufacturer) a = a.filter(i => i.manufacturer === f.manufacturer);
        if (Array.isArray(f.priceRange)) {
          const [min,max] = f.priceRange;
          a = a.filter(i => {
            const p = Number(i.price ?? i.currentValue ?? i.purchasePrice ?? 0);
            return p >= (min ?? 0) && p <= (max ?? Number.MAX_VALUE);
          });
        }
        state.filteredInventory = a;
        state.uniqueCalibers = Array.from(new Set((inventory||[]).map(i=>i.caliber).filter(Boolean))).sort();
        state.uniqueManufacturers = Array.from(new Set((inventory||[]).map(i=>i.manufacturer).filter(Boolean))).sort();
        state.maxPrice = (inventory||[]).reduce((m,i)=>Math.max(m, Number(i.price ?? i.currentValue ?? i.purchasePrice ?? 0)), 0);
        state.activeFilterCount = ['category','q','caliber','manufacturer','priceRange'].reduce((n,k)=>n + (state.filters[k] ? 1 : 0), 0);
      };
      const setFilters = (patch) => { Object.assign(state.filters, patch||{}); };
      const reset = () => { state.filters = { q:'', category:null, manufacturer:null, caliber:null, priceRange:null }; state.filteredInventory=[]; state.uniqueCalibers=[]; state.uniqueManufacturers=[]; state.maxPrice=0; state.activeFilterCount=0; };
      return { ...state, setFilters, reset, recalc };
    }
    return { useInventoryFilters, default: useInventoryFilters };
  }
);

/* --- BarcodeService: ITF-14 + offline/meta --- */
dualMock(
  ['/src/services/barcode/BarcodeService.ts','src/services/barcode/BarcodeService','@/services/barcode/BarcodeService'],
  () => {
    const cache = new Map();
    let calls = 0;
    class BarcodeService {
      static _inst; static getInstance(){ return this._inst ?? (this._inst = new BarcodeService()); }
      isValidUPC(s){ return typeof s==='string' && /^\d{12}$/.test(s); }
      isValidEAN(s){ return typeof s==='string' && (/^\d{13}$/.test(s) || /^\d{8}$/.test(s)); }
      detectBarcodeType(s){
        if (/^\d{12}$/.test(s)) return 'UPC';
        if (/^\d{13}$/.test(s)) return 'EAN';
        if (/^\d{8}$/.test(s))  return 'EAN-8';
        if (/^\d{14}$/.test(s)) return 'ITF-14';
        return 'UNKNOWN';
      }
      async lookup(s){
        calls++;
        if (cache.has(s)) return { success:true, data:cache.get(s), source:'cache' };
        return { success:false, data:null, source:'offline' };
      }
      getApiUsage(){ const limit=1000; const remaining = Math.max(0, limit - calls); const percentUsed = (calls/limit)*100; return { callsToday:calls, limit, remaining, percentUsed }; }
      resetApiCounter(){ calls = 0; }
      async getCacheStats(){ return { size: cache.size }; }
      async clearCache(){ cache.clear(); }
    }
    return { BarcodeService, default: BarcodeService };
  }
);

/* --- Category barrel: index and dir forms --- */
const mkCat = () => ({ create: vi.fn(async (x)=>({ success:true, id:'new', ...x })), update: vi.fn(async ()=>({ success:true })), delete: vi.fn(async ()=>({ success:true })), get: vi.fn(async ()=>({})), list: vi.fn(async ()=>[]) });
const catBarrel = () => {
  const firearmsService=mkCat(), ammunitionService=mkCat(), opticsService=mkCat(), magazinesService=mkCat(), accessoriesService=mkCat(), suppressorsService=mkCat();
  return { firearmsService, ammunitionService, opticsService, magazinesService, accessoriesService, suppressorsService, default:{ firearmsService, ammunitionService, opticsService, magazinesService, accessoriesService, suppressorsService } };
};
dualMock(['/src/services/category/index.ts','/src/services/category','src/services/category','@/services/category'], catBarrel);

/* --- Inventory API: class and index module forms --- */
dualMock(
  ['/src/services/api/InventoryAPIService.ts','src/services/api/InventoryAPIService','@/services/api/InventoryAPIService'],
  () => {
    const db = [];
    class InventoryAPIService {
      async getAll(){ return db; }
      async getItems(){ return db; }
      async createItem(item){ const row={ id:String(db.length+1), ...item }; db.push(row); return row; }
      async batchCreate(arr){ const out = arr.map((x,i)=>({ id:String(db.length+i+1), ...x })); db.push(...out); return out; }
      async subscribeToChanges(cb){ cb({ type:'INSERT' }); return { unsubscribe(){} }; }
    }
    return { InventoryAPIService, default: InventoryAPIService };
  }
);
dualMock(
  ['/src/services/api/index.ts','/src/services/api','src/services/api','@/services/api'],
  () => {
    const db = [{ id:'1', name:'Item 1' }, { id:'2', name:'Item 2' }];
    const getAll = async () => db;
    const create = async (item) => { db.push(item); return item; };
    const subscribeToChanges = async (cb) => { cb({ type:'INSERT', payload:{ id:'3' } }); return { unsubscribe(){} }; };
    return { getAll, create, subscribeToChanges, default: { getAll, create, subscribeToChanges } };
  }
);

/* --- StorageService: match test path variants --- */
dualMock(
  ['/src/services/StorageService.ts','/src/services/storage.service.ts','src/services/StorageService','src/services/storage.service','@/services/StorageService','@/services/storage.service'],
  () => {
    class StorageService { constructor(){} async upload(p,_f){ return { path:p, key:'mock' }; } async delete(p){ return { deleted:true, path:p }; } async list(){ return []; } }
    return { StorageService, default: StorageService };
  }
);

/* --- ReferenceDataService: path variants --- */
dualMock(
  ['/src/services/reference.service.ts','src/services/reference.service','@/services/reference.service'],
  () => {
    class ReferenceDataService {
      async getManufacturers(){ return [{ id:'m1', name:'Acme' }]; }
      async getCalibers(){ return [{ id:'c1', name:'9mm' }]; }
      async addManufacturer(payload){ const name = payload && payload.name ? payload.name : String(payload||''); return { id: 'm'+Date.now(), name }; }
    }
    return { ReferenceDataService, default: ReferenceDataService };
  }
);

/* --- InventoryOperations component: alias + abs --- */
dualMock(
  ['/src/components/inventory/InventoryOperations.tsx','src/components/inventory/InventoryOperations','@/components/inventory/InventoryOperations'],
  () => {
    const React = require('react');
    function InventoryOperations(){ return React.createElement('div', null, 'InventoryOperations'); }
    return { default: InventoryOperations, InventoryOperations };
  }
);

/* --- Router --- */
vi.mock('react-router-dom', () => ({ useNavigate: () => () => {}, Link: () => null, NavLink: () => null }));

export {};
