/* eslint-disable @typescript-eslint/no-explicit-any */
import { vi } from 'vitest';

// ---------- Minimal globals ----------
(globalThis as any).crypto ??= { getRandomValues: (arr: Uint8Array) => { for (let i=0;i<arr.length;i++) arr[i]=Math.floor(Math.random()*256); return arr; } };
class TEnc { encode = (s: string) => new Uint8Array(Buffer.from(s)); }
class TDec { decode = (b: Uint8Array) => Buffer.from(b).toString('utf8'); }
(globalThis as any).TextEncoder ??= TEnc;
(globalThis as any).TextDecoder ??= TDec as any;
(globalThis as any).fetch ??= vi.fn(async () => ({ ok:true, status:200, json:async()=>({}), text:async()=>'', arrayBuffer:async()=>new ArrayBuffer(0) }));

// ---------- Helper: dual-path mock ----------
function dualMock(paths: string[], factory: () => any) { for (const p of paths) vi.mock(p, factory); }
const both = (p: string) => [`@/${p}`, `src/${p}`];

// ---------- lib/utils ----------
dualMock(both('lib/utils'), () => {
  const safeNumber = (v:any, def=0) => { const n = Number(v); return Number.isFinite(n) ? n : def; };
  const validateEmail = (s:string) => /\S+@\S+\.\S+/.test(s ?? '');
  const validateNotEmpty = (s:string) => (s ?? '').trim().length > 0;
  const noop = () => {};
  return {
    safeNumber, validateEmail, validateNotEmpty,
    cn: (...a:any[]) => a.filter(Boolean).join(' '),
    debounce: (fn:any) => fn,
    throttle: (fn:any) => fn,
    default: { safeNumber, validateEmail, validateNotEmpty, noop },
  };
});

// ---------- lib/validation ----------
dualMock(both('lib/validation'), () => {
  const email=/^[^\s@]+@[^\s@]+\.[^\s@]+$/; const url=/^(https?:\/\/)?[\w.-]+(\.[\w.-]+)+[\/#?]?.*$/i;
  const phone=/(^\(\d{3}\)\s?\d{3}[-\s]\d{4}$)|(^\d{3}[-\s]\d{3}[-\s]\d{4}$)/;
  const validateEmail=(s:string)=>email.test(s??'');
  const validatePhone=(s:string)=>phone.test(s??'');
  const validateURL=(s:string)=>url.test(s??'');
  const validateRequired=(v:any)=>!(v===''||v==null);
  return { validateEmail, validatePhone, validateURL, validateRequired };
});

// ---------- error handlers ----------
dualMock(both('lib/databaseErrorHandler'), () => ({
  databaseErrorHandler: () => ({ message:'mock-db-error', code:'MOCK' }),
  default: () => ({ message:'mock-db-error', code:'MOCK' }),
}));
dualMock(both('lib/errorHandler'), () => ({
  errorHandler: () => ({ message:'mock-error' }),
  default: () => ({ message:'mock-error' }),
}));

// ---------- supabase ----------
dualMock(both('lib/supabase'), () => {
  type Row = Record<string, any>;
  const categories: Row[] = Array.from({ length: 12 }).map((_, i) => ({
    id: i + 1,
    name: ['Firearms','Ammunition','Optics','Magazines','Parts','Accessories','Reloading','Safes','Apparel','Cleaning','Archery','Other'][i],
    slug: `cat-${i+1}`,
  }));
  const ok = <T>(data:T) => ({ data, error:null });
  const tables: Record<string, Row[]> = { categories, inventory: [], manufacturers: [], reference_data: [] };

  const from = (table:string) => ({
    select: vi.fn(async (_cols?:string)=> ok((tables[table] ?? []) as any)),
    insert: vi.fn(async (rows:Row|Row[]) => { const arr = Array.isArray(rows)?rows:[rows]; (tables[table] ??= []).push(...arr); return ok(arr as any); }),
    update: vi.fn(async (_patch:Row)=>({ eq: vi.fn((_k:string,_v:any)=> ok((tables[table] ?? []) as any)) })),
    delete: vi.fn(async ()=>({ eq: vi.fn((_k:string,_v:any)=> ok({ deleted:true } as any)) })),
    eq: vi.fn((_k:string,_v:any)=> ok((tables[table] ?? []) as any)),
  });

  const channel = vi.fn((_name:string)=>({ on: vi.fn(()=>({ subscribe: vi.fn(()=>({ unsubscribe(){} })) })) }));
  const auth = {
    getSession: vi.fn(async ()=> ok({ session:{ user:{ id:'test-user' }}})),
    getUser:    vi.fn(async ()=> ok({ user:{ id:'test-user' }})),
  };
  return { supabase:{ from, channel, auth }, from, channel, auth, default:{ from, channel, auth } };
});

// ---------- hooks ----------
dualMock(both('hooks/useSubscription'), () => {
  const hasFeature = (_f:string) => true; // boolean
  return { useSubscription: () => ({ hasFeature }), default: () => ({ hasFeature }) };
});
dualMock(both('hooks/useInventoryFilters'), () => ({
  useInventoryFilters: () => ({ filters:{ q:'', category:null, page:1, pageSize:25 }, setFilters: vi.fn(), reset: vi.fn() }),
  default: () => ({ filters:{}, setFilters: vi.fn(), reset: vi.fn() }),
}));

// ---------- barcode ----------
dualMock(both('services/barcode/BarcodeService'), () => ({
  BarcodeService: class { decode(_s:string){ return { type:'UPC', value:'000000000000' }; } },
  default: class { decode(_s:string){ return { type:'UPC', value:'000000000000' }; } },
}));

// ---------- components ----------
dualMock(both('components/pwa/SmartInstallPrompt'), () => ({ SmartInstallPrompt: () => null, default: () => null }));
dualMock(both('components/inventory/AttributeFields'), () => ({ AttributeFields: (_p:any) => null, default: () => null }));
dualMock(both('components/inventory/InventoryOperations'), () => {
  const InventoryOperations = {
    openCreate: vi.fn(async ()=>({ id:'new-item-id' })),
    openEdit: vi.fn(async (id:string)=>({ id })),
    bulkDelete: vi.fn(async (_ids:string[])=>({ deleted:true })),
  };
  return { InventoryOperations, default: InventoryOperations };
});

// ---------- category services ----------
const categoryServiceStubs = {
  list: vi.fn(async ()=>[]),
  get: vi.fn(async (_id:string|number)=>null),
  create: vi.fn(async (item:any)=>({ id:'new', ...item })),
};
for (const p of [
  'services/categories/firearmsService',
  'services/categories/ammunitionService',
  'services/categories/opticsService',
  'services/categories/accessoriesService',
]) dualMock(both(p), () => ({ ...categoryServiceStubs, default: categoryServiceStubs }));

// ---------- batch ops ----------
dualMock(both('services/BatchOperationsService'), () => ({
  BatchOperationsService: class { async run(ops:any[]){ return { success:true, processed:(ops??[]).length }; } },
  default: class { async run(ops:any[]){ return { success:true, processed:(ops??[]).length }; } },
}));

// ---------- storage ----------
dualMock(both('services/StorageService'), () => {
  class StorageService {
    constructor(_opts?:any) {}
    async upload(path:string,_file:any){ return { path, key:'mock-key' }; }
    async remove(path:string){ return { path, removed:true }; }
    async getUrl(path:string){ return { url:`https://mock/${path}` }; }
  }
  return { StorageService, default: StorageService };
});

// ---------- reference data ----------
dualMock(both('services/ReferenceDataService'), () => {
  class ReferenceDataService {
    async addManufacturer(name:string){ return { id: Date.now(), name }; }
    async listManufacturers(){ return [{ id:1, name:'Acme' }]; }
  }
  return { ReferenceDataService, default: ReferenceDataService };
});

// ---------- inventory api ----------
dualMock(both('services/InventoryAPIService'), () => {
  const db:any[] = [];
  class InventoryAPIService {
    async getAll(){ return db; }
    async getItems(_q?:any){ return db; }
    async createItem(item:any){ const row={ id:`${db.length+1}`, ...item }; db.push(row); return row; }
    async updateItem(id:string, patch:any){ const i=db.findIndex(r=>r.id===id); if(i>=0) db[i]={...db[i],...patch}; return db[i]??null; }
    async deleteItem(id:string){ const i=db.findIndex(r=>r.id===id); if(i>=0) db.splice(i,1); return { deleted:i>=0 }; }
  }
  return { InventoryAPIService, default: InventoryAPIService };
});

// ---------- relative path oddities ----------
vi.mock('../../services/categories/ammunitionService', () => ({ ...categoryServiceStubs, default: categoryServiceStubs }));
vi.mock('../services/categories/ammunitionService', () => ({ ...categoryServiceStubs, default: categoryServiceStubs }));

// ---------- router ----------
vi.mock('react-router-dom', async (importOriginal) => {
  const mod:any = await importOriginal();
  return { ...mod, useNavigate: () => () => {} };
});

// ---------- IDB polyfill ----------
import 'fake-indexeddb/auto';

// ---------- keep ESM happy ----------
export {};

